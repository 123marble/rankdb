// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "rankdb": lists Resource Client
//
// Command:
// $ goagen
// --design=github.com/Vivino/rankdb/api/design
// --out=$(GOPATH)/src/github.com/Vivino/rankdb/api
// --version=v1.3.1

package client

import (
	"bytes"
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
)

// CloneListsPath computes a request path to the clone action of lists.
func CloneListsPath(listID string) string {
	param0 := listID

	return fmt.Sprintf("/lists/%s/clone", param0)
}

// Creates a clone of the list to a new list with the supplied metadata.
// The URL list is the source and the payload must contain the new list ID.
func (c *Client) CloneLists(ctx context.Context, path string, payload *RankList, contentType string) (*http.Response, error) {
	req, err := c.NewCloneListsRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewCloneListsRequest create the request corresponding to the clone action endpoint of the lists resource.
func (c *Client) NewCloneListsRequest(ctx context.Context, path string, payload *RankList, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// CreateListsPath computes a request path to the create action of lists.
func CreateListsPath() string {

	return fmt.Sprintf("/lists")
}

// Create New List.
// If the list already exists "Conflict" will be returned.
// The provided populated data may be provided unsorted, but should not contain duplicate element IDs.
func (c *Client) CreateLists(ctx context.Context, path string, payload *RankList, replace *bool, contentType string) (*http.Response, error) {
	req, err := c.NewCreateListsRequest(ctx, path, payload, replace, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewCreateListsRequest create the request corresponding to the create action endpoint of the lists resource.
func (c *Client) NewCreateListsRequest(ctx context.Context, path string, payload *RankList, replace *bool, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if replace != nil {
		tmp56 := strconv.FormatBool(*replace)
		values.Set("replace", tmp56)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// DeleteListsPath computes a request path to the delete action of lists.
func DeleteListsPath(listID string) string {
	param0 := listID

	return fmt.Sprintf("/lists/%s", param0)
}

// Delete List.
// Also returns success if list was not found.
func (c *Client) DeleteLists(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewDeleteListsRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewDeleteListsRequest create the request corresponding to the delete action endpoint of the lists resource.
func (c *Client) NewDeleteListsRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// GetListsPath computes a request path to the get action of lists.
func GetListsPath(listID string) string {
	param0 := listID

	return fmt.Sprintf("/lists/%s", param0)
}

// Return Single List.
// Note that top and bottom element will be omitted on empty lists.
func (c *Client) GetLists(ctx context.Context, path string, topBottom *bool) (*http.Response, error) {
	req, err := c.NewGetListsRequest(ctx, path, topBottom)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewGetListsRequest create the request corresponding to the get action endpoint of the lists resource.
func (c *Client) NewGetListsRequest(ctx context.Context, path string, topBottom *bool) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if topBottom != nil {
		tmp57 := strconv.FormatBool(*topBottom)
		values.Set("top_bottom", tmp57)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// GetPercentileListsPath computes a request path to the get-percentile action of lists.
func GetPercentileListsPath(listID string) string {
	param0 := listID

	return fmt.Sprintf("/lists/%s/percentile", param0)
}

// Get element at percentile.
// Either `from_top` or `from_bottom` must be supplied
func (c *Client) GetPercentileLists(ctx context.Context, path string, fromTop *string, range_ *int) (*http.Response, error) {
	req, err := c.NewGetPercentileListsRequest(ctx, path, fromTop, range_)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewGetPercentileListsRequest create the request corresponding to the get-percentile action endpoint of the lists resource.
func (c *Client) NewGetPercentileListsRequest(ctx context.Context, path string, fromTop *string, range_ *int) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if fromTop != nil {
		values.Set("from_top", *fromTop)
	}
	if range_ != nil {
		tmp58 := strconv.Itoa(*range_)
		values.Set("range", tmp58)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// GetRangeListsPath computes a request path to the get-range action of lists.
func GetRangeListsPath(listID string) string {
	param0 := listID

	return fmt.Sprintf("/lists/%s/range", param0)
}

// Get rank range of the list.
// Either `from_top` or `from_bottom` must be supplied
func (c *Client) GetRangeLists(ctx context.Context, path string, fromBottom *int, fromTop *int, limit *int) (*http.Response, error) {
	req, err := c.NewGetRangeListsRequest(ctx, path, fromBottom, fromTop, limit)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewGetRangeListsRequest create the request corresponding to the get-range action endpoint of the lists resource.
func (c *Client) NewGetRangeListsRequest(ctx context.Context, path string, fromBottom *int, fromTop *int, limit *int) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if fromBottom != nil {
		tmp59 := strconv.Itoa(*fromBottom)
		values.Set("from_bottom", tmp59)
	}
	if fromTop != nil {
		tmp60 := strconv.Itoa(*fromTop)
		values.Set("from_top", tmp60)
	}
	if limit != nil {
		tmp61 := strconv.Itoa(*limit)
		values.Set("limit", tmp61)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// GetAllListsPath computes a request path to the get_all action of lists.
func GetAllListsPath() string {

	return fmt.Sprintf("/lists")
}

// Get multiple lists.
// Lists are sorted lexicographically. See https://golang.org/pkg/strings/#Compare
func (c *Client) GetAllLists(ctx context.Context, path string, afterID *string, beforeID *string, limit *int) (*http.Response, error) {
	req, err := c.NewGetAllListsRequest(ctx, path, afterID, beforeID, limit)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewGetAllListsRequest create the request corresponding to the get_all action endpoint of the lists resource.
func (c *Client) NewGetAllListsRequest(ctx context.Context, path string, afterID *string, beforeID *string, limit *int) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if afterID != nil {
		values.Set("after_id", *afterID)
	}
	if beforeID != nil {
		values.Set("before_id", *beforeID)
	}
	if limit != nil {
		tmp62 := strconv.Itoa(*limit)
		values.Set("limit", tmp62)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// ReindexListsPath computes a request path to the reindex action of lists.
func ReindexListsPath(listID string) string {
	param0 := listID

	return fmt.Sprintf("/lists/%s/reindex", param0)
}

// Recreates ID index on entire list
func (c *Client) ReindexLists(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewReindexListsRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewReindexListsRequest create the request corresponding to the reindex action endpoint of the lists resource.
func (c *Client) NewReindexListsRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// RepairListsPath computes a request path to the repair action of lists.
func RepairListsPath(listID string) string {
	param0 := listID

	return fmt.Sprintf("/lists/%s/repair", param0)
}

// Repairs the list, by recreating all segments and indexes.
// All access to the list is blocked while operation runs.
func (c *Client) RepairLists(ctx context.Context, path string, clear *bool) (*http.Response, error) {
	req, err := c.NewRepairListsRequest(ctx, path, clear)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewRepairListsRequest create the request corresponding to the repair action endpoint of the lists resource.
func (c *Client) NewRepairListsRequest(ctx context.Context, path string, clear *bool) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if clear != nil {
		tmp63 := strconv.FormatBool(*clear)
		values.Set("clear", tmp63)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// VerifyListsPath computes a request path to the verify action of lists.
func VerifyListsPath(listID string) string {
	param0 := listID

	return fmt.Sprintf("/lists/%s/verify", param0)
}

// Verify the list and its elements and optionally repair it.
// All write access to the list is blocked while operation runs.
func (c *Client) VerifyLists(ctx context.Context, path string, clear *bool, repair *bool) (*http.Response, error) {
	req, err := c.NewVerifyListsRequest(ctx, path, clear, repair)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewVerifyListsRequest create the request corresponding to the verify action endpoint of the lists resource.
func (c *Client) NewVerifyListsRequest(ctx context.Context, path string, clear *bool, repair *bool) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if clear != nil {
		tmp64 := strconv.FormatBool(*clear)
		values.Set("clear", tmp64)
	}
	if repair != nil {
		tmp65 := strconv.FormatBool(*repair)
		values.Set("repair", tmp65)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}
