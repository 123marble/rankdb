// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "rankdb": Application Media Types
//
// Command:
// $ goagen
// --design=github.com/Vivino/rankdb/api/design
// --out=$(GOPATH)/src/github.com/Vivino/rankdb/api
// --version=v1.3.1

package client

import (
	"encoding/json"
	"net/http"
	"time"
	"unicode/utf8"

	"github.com/goadesign/goa"
)

// DecodeErrorResponse decodes the ErrorResponse instance encoded in resp body.
func (c *Client) DecodeErrorResponse(resp *http.Response) (*goa.ErrorResponse, error) {
	var decoded goa.ErrorResponse
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Backup Information (default view)
//
// Identifier: application/vnd.rankdb.backup_status+json; view=default
type RankdbBackupStatus struct {
	// Will be true if backup was cancelled
	Cancelled bool `form:"cancelled" json:"cancelled" xml:"cancelled"`
	// Custom information provided by backup
	Custom map[string]string `form:"custom,omitempty" json:"custom,omitempty" xml:"custom,omitempty"`
	// Will be true when the backup has finished processing
	Done bool `form:"done" json:"done" xml:"done"`
	// Failed operations, indexed by list IDs
	Errors map[string]string `form:"errors,omitempty" json:"errors,omitempty" xml:"errors,omitempty"`
	// Time backup was finished
	Finished *time.Time `form:"finished,omitempty" json:"finished,omitempty" xml:"finished,omitempty"`
	// Number of lists to be backed up
	Lists int `form:"lists" json:"lists" xml:"lists"`
	// Number of lists backed up now
	ListsDone int `form:"lists_done" json:"lists_done" xml:"lists_done"`
	// Size of stored data
	Size int64 `form:"size" json:"size" xml:"size"`
	// Time backup was started
	Started time.Time `form:"started" json:"started" xml:"started"`
	// Storage used for backup
	Storage string `form:"storage" json:"storage" xml:"storage"`
	// URI of backed up content. Used for restore.
	URI string `form:"uri" json:"uri" xml:"uri"`
}

// Validate validates the RankdbBackupStatus media type instance.
func (mt *RankdbBackupStatus) Validate() (err error) {

	if mt.Storage == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "storage"))
	}

	if mt.URI == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "uri"))
	}

	return
}

// Backup Information (full view)
//
// Identifier: application/vnd.rankdb.backup_status+json; view=full
type RankdbBackupStatusFull struct {
	// Will be true if backup was cancelled
	Cancelled bool `form:"cancelled" json:"cancelled" xml:"cancelled"`
	// Custom information provided by backup
	Custom map[string]string `form:"custom,omitempty" json:"custom,omitempty" xml:"custom,omitempty"`
	// Will be true when the backup has finished processing
	Done bool `form:"done" json:"done" xml:"done"`
	// Failed operations, indexed by list IDs
	Errors map[string]string `form:"errors,omitempty" json:"errors,omitempty" xml:"errors,omitempty"`
	// Time backup was finished
	Finished *time.Time `form:"finished,omitempty" json:"finished,omitempty" xml:"finished,omitempty"`
	// Number of lists to be backed up
	Lists int `form:"lists" json:"lists" xml:"lists"`
	// Number of lists backed up now
	ListsDone int `form:"lists_done" json:"lists_done" xml:"lists_done"`
	// Size of stored data
	Size int64 `form:"size" json:"size" xml:"size"`
	// Time backup was started
	Started time.Time `form:"started" json:"started" xml:"started"`
	// Storage used for backup
	Storage string `form:"storage" json:"storage" xml:"storage"`
	// Successful operations, list IDs
	Success []string `form:"success,omitempty" json:"success,omitempty" xml:"success,omitempty"`
	// URI of backed up content. Used for restore.
	URI string `form:"uri" json:"uri" xml:"uri"`
}

// Validate validates the RankdbBackupStatusFull media type instance.
func (mt *RankdbBackupStatusFull) Validate() (err error) {

	if mt.Storage == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "storage"))
	}

	if mt.URI == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "uri"))
	}

	return
}

// Backup Information (tiny view)
//
// Identifier: application/vnd.rankdb.backup_status+json; view=tiny
type RankdbBackupStatusTiny struct {
	// Will be true if backup was cancelled
	Cancelled bool `form:"cancelled" json:"cancelled" xml:"cancelled"`
	// Will be true when the backup has finished processing
	Done bool `form:"done" json:"done" xml:"done"`
	// Time backup was finished
	Finished *time.Time `form:"finished,omitempty" json:"finished,omitempty" xml:"finished,omitempty"`
	// Number of lists to be backed up
	Lists int `form:"lists" json:"lists" xml:"lists"`
	// Number of lists backed up now
	ListsDone int `form:"lists_done" json:"lists_done" xml:"lists_done"`
	// Size of stored data
	Size int64 `form:"size" json:"size" xml:"size"`
	// Time backup was started
	Started time.Time `form:"started" json:"started" xml:"started"`
	// URI of backed up content. Used for restore.
	URI string `form:"uri" json:"uri" xml:"uri"`
}

// Validate validates the RankdbBackupStatusTiny media type instance.
func (mt *RankdbBackupStatusTiny) Validate() (err error) {

	if mt.URI == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "uri"))
	}

	return
}

// DecodeRankdbBackupStatus decodes the RankdbBackupStatus instance encoded in resp body.
func (c *Client) DecodeRankdbBackupStatus(resp *http.Response) (*RankdbBackupStatus, error) {
	var decoded RankdbBackupStatus
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeRankdbBackupStatusFull decodes the RankdbBackupStatusFull instance encoded in resp body.
func (c *Client) DecodeRankdbBackupStatusFull(resp *http.Response) (*RankdbBackupStatusFull, error) {
	var decoded RankdbBackupStatusFull
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeRankdbBackupStatusTiny decodes the RankdbBackupStatusTiny instance encoded in resp body.
func (c *Client) DecodeRankdbBackupStatusTiny(resp *http.Response) (*RankdbBackupStatusTiny, error) {
	var decoded RankdbBackupStatusTiny
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Backup Information (default view)
//
// Identifier: application/vnd.rankdb.callback+json; view=default
type RankdbCallback struct {
	CallbackURL string `form:"callback_url" json:"callback_url" xml:"callback_url"`
	ID          string `form:"id" json:"id" xml:"id"`
}

// Validate validates the RankdbCallback media type instance.
func (mt *RankdbCallback) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.CallbackURL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "callback_url"))
	}
	return
}

// DecodeRankdbCallback decodes the RankdbCallback instance encoded in resp body.
func (c *Client) DecodeRankdbCallback(resp *http.Response) (*RankdbCallback, error) {
	var decoded RankdbCallback
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// List Element (default view)
//
// Identifier: application/vnd.rankdb.element+json; view=default
type RankdbElement struct {
	// Element rank in list from bottom.
	//  Bottom element has value 0.
	FromBottom int `form:"from_bottom" json:"from_bottom" xml:"from_bottom"`
	// Element rank in list from top.
	//  Top element has value 0.
	FromTop int `form:"from_top" json:"from_top" xml:"from_top"`
	// ID of element
	ID uint64 `form:"id" json:"id" xml:"id"`
	// The ID of the list to apply the operation on.
	// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
	ListID string `form:"list_id" json:"list_id" xml:"list_id"`
	// Custom payload. Stored untouched. On updates null means do not update. `{}` is the empty value.
	Payload json.RawMessage `form:"payload" json:"payload" xml:"payload"`
	// Score of the element. Higher score gives higher placement.
	Score uint64 `form:"score" json:"score" xml:"score"`
	// Tie breaker, used if score matches for consistent sorting. Higher value = higher placement if score is equal.
	TieBreaker uint32 `form:"tie_breaker" json:"tie_breaker" xml:"tie_breaker"`
	// Date of last update
	UpdatedAt time.Time `form:"updated_at" json:"updated_at" xml:"updated_at"`
}

// Validate validates the RankdbElement media type instance.
func (mt *RankdbElement) Validate() (err error) {

	if mt.ListID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "list_id"))
	}
	if mt.Payload == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "payload"))
	}

	if mt.ID < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.id`, mt.ID, 0, true))
	}
	if ok := goa.ValidatePattern(`^[a-zA-Z0-9-_.]+$`, mt.ListID); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.list_id`, mt.ListID, `^[a-zA-Z0-9-_.]+$`))
	}
	if utf8.RuneCountInString(mt.ListID) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.list_id`, mt.ListID, utf8.RuneCountInString(mt.ListID), 2, true))
	}
	if utf8.RuneCountInString(mt.ListID) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.list_id`, mt.ListID, utf8.RuneCountInString(mt.ListID), 100, false))
	}
	if mt.Score < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.score`, mt.Score, 0, true))
	}
	if mt.TieBreaker < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.tie_breaker`, mt.TieBreaker, 0, true))
	}
	if mt.TieBreaker > 4294967295 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.tie_breaker`, mt.TieBreaker, 4294967295, false))
	}
	return
}

// List Element (full view)
//
// Identifier: application/vnd.rankdb.element+json; view=full
type RankdbElementFull struct {
	// Element rank in list from bottom.
	//  Bottom element has value 0.
	FromBottom int `form:"from_bottom" json:"from_bottom" xml:"from_bottom"`
	// Element rank in list from top.
	//  Top element has value 0.
	FromTop int `form:"from_top" json:"from_top" xml:"from_top"`
	// ID of element
	ID uint64 `form:"id" json:"id" xml:"id"`
	// The ID of the list to apply the operation on.
	// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
	ListID string `form:"list_id" json:"list_id" xml:"list_id"`
	// Local element rank in list from bottom when requesting sub-list.
	//  Bottom element has value 0.
	LocalFromBottom *int `form:"local_from_bottom,omitempty" json:"local_from_bottom,omitempty" xml:"local_from_bottom,omitempty"`
	// Local element rank in list from top when requesting sub-list.
	//  Top element has value 0.
	LocalFromTop *int `form:"local_from_top,omitempty" json:"local_from_top,omitempty" xml:"local_from_top,omitempty"`
	// Neighbors to current element
	Neighbors *struct {
		// Elements above the current element.
		// Ends with element just above current.
		Above RankdbElementCollection `form:"above,omitempty" json:"above,omitempty" xml:"above,omitempty"`
		// Elements below the current element.
		// Starts with element just below current.
		Below RankdbElementCollection `form:"below,omitempty" json:"below,omitempty" xml:"below,omitempty"`
	} `form:"neighbors,omitempty" json:"neighbors,omitempty" xml:"neighbors,omitempty"`
	// Custom payload. Stored untouched. On updates null means do not update. `{}` is the empty value.
	Payload json.RawMessage `form:"payload" json:"payload" xml:"payload"`
	// Score of the element. Higher score gives higher placement.
	Score uint64 `form:"score" json:"score" xml:"score"`
	// Tie breaker, used if score matches for consistent sorting. Higher value = higher placement if score is equal.
	TieBreaker uint32 `form:"tie_breaker" json:"tie_breaker" xml:"tie_breaker"`
	// Date of last update
	UpdatedAt time.Time `form:"updated_at" json:"updated_at" xml:"updated_at"`
}

// Validate validates the RankdbElementFull media type instance.
func (mt *RankdbElementFull) Validate() (err error) {

	if mt.ListID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "list_id"))
	}
	if mt.Payload == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "payload"))
	}

	if mt.ID < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.id`, mt.ID, 0, true))
	}
	if ok := goa.ValidatePattern(`^[a-zA-Z0-9-_.]+$`, mt.ListID); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.list_id`, mt.ListID, `^[a-zA-Z0-9-_.]+$`))
	}
	if utf8.RuneCountInString(mt.ListID) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.list_id`, mt.ListID, utf8.RuneCountInString(mt.ListID), 2, true))
	}
	if utf8.RuneCountInString(mt.ListID) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.list_id`, mt.ListID, utf8.RuneCountInString(mt.ListID), 100, false))
	}
	if mt.Neighbors != nil {
		if err2 := mt.Neighbors.Above.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
		if err2 := mt.Neighbors.Below.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Score < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.score`, mt.Score, 0, true))
	}
	if mt.TieBreaker < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.tie_breaker`, mt.TieBreaker, 0, true))
	}
	if mt.TieBreaker > 4294967295 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.tie_breaker`, mt.TieBreaker, 4294967295, false))
	}
	return
}

// List Element (full-update view)
//
// Identifier: application/vnd.rankdb.element+json; view=full-update
type RankdbElementFullUpdate struct {
	// Element rank in list from bottom.
	//  Bottom element has value 0.
	FromBottom int `form:"from_bottom" json:"from_bottom" xml:"from_bottom"`
	// Element rank in list from top.
	//  Top element has value 0.
	FromTop int `form:"from_top" json:"from_top" xml:"from_top"`
	// ID of element
	ID uint64 `form:"id" json:"id" xml:"id"`
	// The ID of the list to apply the operation on.
	// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
	ListID string `form:"list_id" json:"list_id" xml:"list_id"`
	// Local element rank in list from bottom when requesting sub-list.
	//  Bottom element has value 0.
	LocalFromBottom *int `form:"local_from_bottom,omitempty" json:"local_from_bottom,omitempty" xml:"local_from_bottom,omitempty"`
	// Local element rank in list from top when requesting sub-list.
	//  Top element has value 0.
	LocalFromTop *int `form:"local_from_top,omitempty" json:"local_from_top,omitempty" xml:"local_from_top,omitempty"`
	// Neighbors to current element
	Neighbors *struct {
		// Elements above the current element.
		// Ends with element just above current.
		Above RankdbElementCollection `form:"above,omitempty" json:"above,omitempty" xml:"above,omitempty"`
		// Elements below the current element.
		// Starts with element just below current.
		Below RankdbElementCollection `form:"below,omitempty" json:"below,omitempty" xml:"below,omitempty"`
	} `form:"neighbors,omitempty" json:"neighbors,omitempty" xml:"neighbors,omitempty"`
	// Custom payload. Stored untouched. On updates null means do not update. `{}` is the empty value.
	Payload json.RawMessage `form:"payload" json:"payload" xml:"payload"`
	// Rank of element before update
	PreviousRank *RankdbElement `form:"previous_rank,omitempty" json:"previous_rank,omitempty" xml:"previous_rank,omitempty"`
	// Score of the element. Higher score gives higher placement.
	Score uint64 `form:"score" json:"score" xml:"score"`
	// Tie breaker, used if score matches for consistent sorting. Higher value = higher placement if score is equal.
	TieBreaker uint32 `form:"tie_breaker" json:"tie_breaker" xml:"tie_breaker"`
	// Date of last update
	UpdatedAt time.Time `form:"updated_at" json:"updated_at" xml:"updated_at"`
}

// Validate validates the RankdbElementFullUpdate media type instance.
func (mt *RankdbElementFullUpdate) Validate() (err error) {

	if mt.ListID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "list_id"))
	}
	if mt.Payload == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "payload"))
	}

	if mt.ID < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.id`, mt.ID, 0, true))
	}
	if ok := goa.ValidatePattern(`^[a-zA-Z0-9-_.]+$`, mt.ListID); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.list_id`, mt.ListID, `^[a-zA-Z0-9-_.]+$`))
	}
	if utf8.RuneCountInString(mt.ListID) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.list_id`, mt.ListID, utf8.RuneCountInString(mt.ListID), 2, true))
	}
	if utf8.RuneCountInString(mt.ListID) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.list_id`, mt.ListID, utf8.RuneCountInString(mt.ListID), 100, false))
	}
	if mt.Neighbors != nil {
		if err2 := mt.Neighbors.Above.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
		if err2 := mt.Neighbors.Below.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.PreviousRank != nil {
		if err2 := mt.PreviousRank.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if mt.Score < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.score`, mt.Score, 0, true))
	}
	if mt.TieBreaker < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.tie_breaker`, mt.TieBreaker, 0, true))
	}
	if mt.TieBreaker > 4294967295 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.tie_breaker`, mt.TieBreaker, 4294967295, false))
	}
	return
}

// List Element (tiny view)
//
// Identifier: application/vnd.rankdb.element+json; view=tiny
type RankdbElementTiny struct {
	// Element rank in list from bottom.
	//  Bottom element has value 0.
	FromBottom int `form:"from_bottom" json:"from_bottom" xml:"from_bottom"`
	// Element rank in list from top.
	//  Top element has value 0.
	FromTop int `form:"from_top" json:"from_top" xml:"from_top"`
	// ID of element
	ID uint64 `form:"id" json:"id" xml:"id"`
	// Custom payload. Stored untouched. On updates null means do not update. `{}` is the empty value.
	Payload json.RawMessage `form:"payload" json:"payload" xml:"payload"`
	// Score of the element. Higher score gives higher placement.
	Score uint64 `form:"score" json:"score" xml:"score"`
}

// Validate validates the RankdbElementTiny media type instance.
func (mt *RankdbElementTiny) Validate() (err error) {

	if mt.Payload == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "payload"))
	}
	if mt.ID < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.id`, mt.ID, 0, true))
	}
	if mt.Score < 0 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.score`, mt.Score, 0, true))
	}
	return
}

// DecodeRankdbElement decodes the RankdbElement instance encoded in resp body.
func (c *Client) DecodeRankdbElement(resp *http.Response) (*RankdbElement, error) {
	var decoded RankdbElement
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeRankdbElementFull decodes the RankdbElementFull instance encoded in resp body.
func (c *Client) DecodeRankdbElementFull(resp *http.Response) (*RankdbElementFull, error) {
	var decoded RankdbElementFull
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeRankdbElementFullUpdate decodes the RankdbElementFullUpdate instance encoded in resp body.
func (c *Client) DecodeRankdbElementFullUpdate(resp *http.Response) (*RankdbElementFullUpdate, error) {
	var decoded RankdbElementFullUpdate
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeRankdbElementTiny decodes the RankdbElementTiny instance encoded in resp body.
func (c *Client) DecodeRankdbElementTiny(resp *http.Response) (*RankdbElementTiny, error) {
	var decoded RankdbElementTiny
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// RankdbElementCollection is the media type for an array of RankdbElement (default view)
//
// Identifier: application/vnd.rankdb.element+json; type=collection; view=default
type RankdbElementCollection []*RankdbElement

// Validate validates the RankdbElementCollection media type instance.
func (mt RankdbElementCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// RankdbElementCollection is the media type for an array of RankdbElement (full view)
//
// Identifier: application/vnd.rankdb.element+json; type=collection; view=full
type RankdbElementFullCollection []*RankdbElementFull

// Validate validates the RankdbElementFullCollection media type instance.
func (mt RankdbElementFullCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// RankdbElementCollection is the media type for an array of RankdbElement (full-update view)
//
// Identifier: application/vnd.rankdb.element+json; type=collection; view=full-update
type RankdbElementFullUpdateCollection []*RankdbElementFullUpdate

// Validate validates the RankdbElementFullUpdateCollection media type instance.
func (mt RankdbElementFullUpdateCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// RankdbElementCollection is the media type for an array of RankdbElement (tiny view)
//
// Identifier: application/vnd.rankdb.element+json; type=collection; view=tiny
type RankdbElementTinyCollection []*RankdbElementTiny

// Validate validates the RankdbElementTinyCollection media type instance.
func (mt RankdbElementTinyCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeRankdbElementCollection decodes the RankdbElementCollection instance encoded in resp body.
func (c *Client) DecodeRankdbElementCollection(resp *http.Response) (RankdbElementCollection, error) {
	var decoded RankdbElementCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodeRankdbElementFullCollection decodes the RankdbElementFullCollection instance encoded in resp body.
func (c *Client) DecodeRankdbElementFullCollection(resp *http.Response) (RankdbElementFullCollection, error) {
	var decoded RankdbElementFullCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodeRankdbElementFullUpdateCollection decodes the RankdbElementFullUpdateCollection instance encoded in resp body.
func (c *Client) DecodeRankdbElementFullUpdateCollection(resp *http.Response) (RankdbElementFullUpdateCollection, error) {
	var decoded RankdbElementFullUpdateCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodeRankdbElementTinyCollection decodes the RankdbElementTinyCollection instance encoded in resp body.
func (c *Client) DecodeRankdbElementTinyCollection(resp *http.Response) (RankdbElementTinyCollection, error) {
	var decoded RankdbElementTinyCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// Result of a list operation. Will contain either an error or a list. (default view)
//
// Identifier: application/vnd.rankdb.listopresult+json; view=default
type RankdbListopresult struct {
	// Error, if any encountered
	Error *string         `form:"error,omitempty" json:"error,omitempty" xml:"error,omitempty"`
	List  *RankdbRanklist `form:"list,omitempty" json:"list,omitempty" xml:"list,omitempty"`
}

// Validate validates the RankdbListopresult media type instance.
func (mt *RankdbListopresult) Validate() (err error) {
	if mt.List != nil {
		if err2 := mt.List.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// DecodeRankdbListopresult decodes the RankdbListopresult instance encoded in resp body.
func (c *Client) DecodeRankdbListopresult(resp *http.Response) (*RankdbListopresult, error) {
	var decoded RankdbListopresult
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// RankdbListsresult media type (default view)
//
// Identifier: application/vnd.rankdb.listsresult+json; view=default
type RankdbListsresult struct {
	Lists RankdbRanklistCollection `form:"lists" json:"lists" xml:"lists"`
	// The number of lists after the last element
	ListsAfter int `form:"lists_after" json:"lists_after" xml:"lists_after"`
	// The number of lists before the first element
	ListsBefore int `form:"lists_before" json:"lists_before" xml:"lists_before"`
}

// Validate validates the RankdbListsresult media type instance.
func (mt *RankdbListsresult) Validate() (err error) {

	if mt.Lists == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "lists"))
	}
	if err2 := mt.Lists.Validate(); err2 != nil {
		err = goa.MergeErrors(err, err2)
	}
	return
}

// DecodeRankdbListsresult decodes the RankdbListsresult instance encoded in resp body.
func (c *Client) DecodeRankdbListsresult(resp *http.Response) (*RankdbListsresult, error) {
	var decoded RankdbListsresult
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// RankdbMultielement media type (default view)
//
// Identifier: application/vnd.rankdb.multielement+json; view=default
type RankdbMultielement struct {
	// Elements that was found in the list, ordered by score.
	Found RankdbElementCollection `form:"found" json:"found" xml:"found"`
	// Elements that wasn't found in the list. Unordered.
	NotFound []uint64 `form:"not_found,omitempty" json:"not_found,omitempty" xml:"not_found,omitempty"`
}

// Validate validates the RankdbMultielement media type instance.
func (mt *RankdbMultielement) Validate() (err error) {
	if mt.Found == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "found"))
	}
	if err2 := mt.Found.Validate(); err2 != nil {
		err = goa.MergeErrors(err, err2)
	}
	return
}

// DecodeRankdbMultielement decodes the RankdbMultielement instance encoded in resp body.
func (c *Client) DecodeRankdbMultielement(resp *http.Response) (*RankdbMultielement, error) {
	var decoded RankdbMultielement
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// RankdbOperation_success media type (default view)
//
// Identifier: application/vnd.rankdb.operation_success+json; view=default
type RankdbOperationSuccess struct {
	// If `results` parameter was true, the resulting element is returned here.
	Results RankdbElementTinyCollection `form:"results,omitempty" json:"results,omitempty" xml:"results,omitempty"`
}

// Validate validates the RankdbOperationSuccess media type instance.
func (mt *RankdbOperationSuccess) Validate() (err error) {
	if err2 := mt.Results.Validate(); err2 != nil {
		err = goa.MergeErrors(err, err2)
	}
	return
}

// DecodeRankdbOperationSuccess decodes the RankdbOperationSuccess instance encoded in resp body.
func (c *Client) DecodeRankdbOperationSuccess(resp *http.Response) (*RankdbOperationSuccess, error) {
	var decoded RankdbOperationSuccess
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// Rank List (default view)
//
// Identifier: application/vnd.rankdb.ranklist+json; view=default
type RankdbRanklist struct {
	// The ID of the list to apply the operation on.
	// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
	ID string `form:"id" json:"id" xml:"id"`
	// Load Index on server startup
	LoadIndex bool `form:"load_index" json:"load_index" xml:"load_index"`
	// Merge adjacent Segments with less than this number of entries
	MergeSize int `form:"merge_size" json:"merge_size" xml:"merge_size"`
	// Custom metadata. String to String hash.
	Metadata map[string]string `form:"metadata" json:"metadata" xml:"metadata"`
	// Set used for storage
	Set string `form:"set" json:"set" xml:"set"`
	// Split Segments larger than this number of entries
	SplitSize int `form:"split_size" json:"split_size" xml:"split_size"`
}

// Validate validates the RankdbRanklist media type instance.
func (mt *RankdbRanklist) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Set == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "set"))
	}
	if mt.Metadata == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "metadata"))
	}

	if ok := goa.ValidatePattern(`^[a-zA-Z0-9-_.]+$`, mt.ID); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.id`, mt.ID, `^[a-zA-Z0-9-_.]+$`))
	}
	if utf8.RuneCountInString(mt.ID) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.id`, mt.ID, utf8.RuneCountInString(mt.ID), 2, true))
	}
	if utf8.RuneCountInString(mt.ID) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.id`, mt.ID, utf8.RuneCountInString(mt.ID), 100, false))
	}
	if mt.MergeSize < 10 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.merge_size`, mt.MergeSize, 10, true))
	}
	if mt.MergeSize > 100000 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.merge_size`, mt.MergeSize, 100000, false))
	}
	if utf8.RuneCountInString(mt.Set) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.set`, mt.Set, utf8.RuneCountInString(mt.Set), 2, true))
	}
	if utf8.RuneCountInString(mt.Set) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.set`, mt.Set, utf8.RuneCountInString(mt.Set), 100, false))
	}
	if mt.SplitSize < 10 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.split_size`, mt.SplitSize, 10, true))
	}
	if mt.SplitSize > 100000 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.split_size`, mt.SplitSize, 100000, false))
	}
	return
}

// Rank List (full view)
//
// Identifier: application/vnd.rankdb.ranklist+json; view=full
type RankdbRanklistFull struct {
	// Average number of elements per segment
	AvgSegmentElements float64        `form:"avg_segment_elements" json:"avg_segment_elements" xml:"avg_segment_elements"`
	BottomElement      *RankdbElement `form:"bottom_element,omitempty" json:"bottom_element,omitempty" xml:"bottom_element,omitempty"`
	// Cache hits while segments have been loaded.
	CacheHits int `form:"cache_hits" json:"cache_hits" xml:"cache_hits"`
	// Cache misses while segments have been loaded.
	CacheMisses int `form:"cache_misses" json:"cache_misses" xml:"cache_misses"`
	// Cache hit percentage while segments have been loaded.
	CachePercent float64 `form:"cache_percent" json:"cache_percent" xml:"cache_percent"`
	// Number of elements in list
	Elements int `form:"elements" json:"elements" xml:"elements"`
	// The ID of the list to apply the operation on.
	// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
	ID string `form:"id" json:"id" xml:"id"`
	// Load Index on server startup
	LoadIndex bool `form:"load_index" json:"load_index" xml:"load_index"`
	// Merge adjacent Segments with less than this number of entries
	MergeSize int `form:"merge_size" json:"merge_size" xml:"merge_size"`
	// Custom metadata. String to String hash.
	Metadata map[string]string `form:"metadata" json:"metadata" xml:"metadata"`
	// Number of segment in list
	Segments int `form:"segments" json:"segments" xml:"segments"`
	// Set used for storage
	Set string `form:"set" json:"set" xml:"set"`
	// Split Segments larger than this number of entries
	SplitSize int `form:"split_size" json:"split_size" xml:"split_size"`
	// This element is only returned if 'top_bottom' parameter is set to true.
	TopElement *RankdbElement `form:"top_element,omitempty" json:"top_element,omitempty" xml:"top_element,omitempty"`
}

// Validate validates the RankdbRanklistFull media type instance.
func (mt *RankdbRanklistFull) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.Set == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "set"))
	}
	if mt.Metadata == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "metadata"))
	}

	if mt.BottomElement != nil {
		if err2 := mt.BottomElement.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ok := goa.ValidatePattern(`^[a-zA-Z0-9-_.]+$`, mt.ID); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.id`, mt.ID, `^[a-zA-Z0-9-_.]+$`))
	}
	if utf8.RuneCountInString(mt.ID) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.id`, mt.ID, utf8.RuneCountInString(mt.ID), 2, true))
	}
	if utf8.RuneCountInString(mt.ID) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.id`, mt.ID, utf8.RuneCountInString(mt.ID), 100, false))
	}
	if mt.MergeSize < 10 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.merge_size`, mt.MergeSize, 10, true))
	}
	if mt.MergeSize > 100000 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.merge_size`, mt.MergeSize, 100000, false))
	}
	if utf8.RuneCountInString(mt.Set) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.set`, mt.Set, utf8.RuneCountInString(mt.Set), 2, true))
	}
	if utf8.RuneCountInString(mt.Set) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.set`, mt.Set, utf8.RuneCountInString(mt.Set), 100, false))
	}
	if mt.SplitSize < 10 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.split_size`, mt.SplitSize, 10, true))
	}
	if mt.SplitSize > 100000 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.split_size`, mt.SplitSize, 100000, false))
	}
	if mt.TopElement != nil {
		if err2 := mt.TopElement.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Rank List (tiny view)
//
// Identifier: application/vnd.rankdb.ranklist+json; view=tiny
type RankdbRanklistTiny struct {
	// The ID of the list to apply the operation on.
	// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
	ID string `form:"id" json:"id" xml:"id"`
}

// Validate validates the RankdbRanklistTiny media type instance.
func (mt *RankdbRanklistTiny) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if ok := goa.ValidatePattern(`^[a-zA-Z0-9-_.]+$`, mt.ID); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.id`, mt.ID, `^[a-zA-Z0-9-_.]+$`))
	}
	if utf8.RuneCountInString(mt.ID) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.id`, mt.ID, utf8.RuneCountInString(mt.ID), 2, true))
	}
	if utf8.RuneCountInString(mt.ID) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`response.id`, mt.ID, utf8.RuneCountInString(mt.ID), 100, false))
	}
	return
}

// DecodeRankdbRanklist decodes the RankdbRanklist instance encoded in resp body.
func (c *Client) DecodeRankdbRanklist(resp *http.Response) (*RankdbRanklist, error) {
	var decoded RankdbRanklist
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeRankdbRanklistFull decodes the RankdbRanklistFull instance encoded in resp body.
func (c *Client) DecodeRankdbRanklistFull(resp *http.Response) (*RankdbRanklistFull, error) {
	var decoded RankdbRanklistFull
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeRankdbRanklistTiny decodes the RankdbRanklistTiny instance encoded in resp body.
func (c *Client) DecodeRankdbRanklistTiny(resp *http.Response) (*RankdbRanklistTiny, error) {
	var decoded RankdbRanklistTiny
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// RankdbRanklistCollection is the media type for an array of RankdbRanklist (default view)
//
// Identifier: application/vnd.rankdb.ranklist+json; type=collection; view=default
type RankdbRanklistCollection []*RankdbRanklist

// Validate validates the RankdbRanklistCollection media type instance.
func (mt RankdbRanklistCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// RankdbRanklistCollection is the media type for an array of RankdbRanklist (tiny view)
//
// Identifier: application/vnd.rankdb.ranklist+json; type=collection; view=tiny
type RankdbRanklistTinyCollection []*RankdbRanklistTiny

// Validate validates the RankdbRanklistTinyCollection media type instance.
func (mt RankdbRanklistTinyCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeRankdbRanklistCollection decodes the RankdbRanklistCollection instance encoded in resp body.
func (c *Client) DecodeRankdbRanklistCollection(resp *http.Response) (RankdbRanklistCollection, error) {
	var decoded RankdbRanklistCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodeRankdbRanklistTinyCollection decodes the RankdbRanklistTinyCollection instance encoded in resp body.
func (c *Client) DecodeRankdbRanklistTinyCollection(resp *http.Response) (RankdbRanklistTinyCollection, error) {
	var decoded RankdbRanklistTinyCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// RankdbRestoreresult media type (default view)
//
// Identifier: application/vnd.rankdb.restoreresult+json; view=default
type RankdbRestoreresult struct {
	// Failed operations, indexed by list IDs
	Errors map[string]string `form:"errors" json:"errors" xml:"errors"`
	// Successful restore operations, indexed by list IDs
	Restored int `form:"restored" json:"restored" xml:"restored"`
	// Skipped lists, indexed by list IDs
	Skipped int `form:"skipped" json:"skipped" xml:"skipped"`
}

// Validate validates the RankdbRestoreresult media type instance.
func (mt *RankdbRestoreresult) Validate() (err error) {

	if mt.Errors == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "errors"))
	}
	return
}

// DecodeRankdbRestoreresult decodes the RankdbRestoreresult instance encoded in resp body.
func (c *Client) DecodeRankdbRestoreresult(resp *http.Response) (*RankdbRestoreresult, error) {
	var decoded RankdbRestoreresult
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// RankdbResultlist media type (default view)
//
// Identifier: application/vnd.rankdb.resultlist+json; view=default
type RankdbResultlist struct {
	// Failed operations, indexed by list IDs
	Errors map[string]string `form:"errors,omitempty" json:"errors,omitempty" xml:"errors,omitempty"`
	// Successful operations, indexed by list IDs
	Success map[string]*RankdbOperationSuccess `form:"success,omitempty" json:"success,omitempty" xml:"success,omitempty"`
}

// Validate validates the RankdbResultlist media type instance.
func (mt *RankdbResultlist) Validate() (err error) {
	for _, e := range mt.Success {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeRankdbResultlist decodes the RankdbResultlist instance encoded in resp body.
func (c *Client) DecodeRankdbResultlist(resp *http.Response) (*RankdbResultlist, error) {
	var decoded RankdbResultlist
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// System Info. The model is sparse and may contain other information. (default view)
//
// Identifier: application/vnd.rankdb.sysinfo+json; view=default
type RankdbSysinfo struct {
	// Element Cache Information
	ElementCache map[string]interface{} `form:"element_cache,omitempty" json:"element_cache,omitempty" xml:"element_cache,omitempty"`
	// Lazy saver cache information.
	LazySaver json.RawMessage `form:"lazy_saver,omitempty" json:"lazy_saver,omitempty" xml:"lazy_saver,omitempty"`
	// Memory Information
	Memory map[string]interface{} `form:"memory,omitempty" json:"memory,omitempty" xml:"memory,omitempty"`
}

// DecodeRankdbSysinfo decodes the RankdbSysinfo instance encoded in resp body.
func (c *Client) DecodeRankdbSysinfo(resp *http.Response) (*RankdbSysinfo, error) {
	var decoded RankdbSysinfo
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}
