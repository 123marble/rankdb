// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "rankdb": multilist Resource Client
//
// Command:
// $ goagen
// --design=github.com/Vivino/rankdb/api/design
// --out=$(GOPATH)/src/github.com/Vivino/rankdb/api
// --version=v1.3.1

package client

import (
	"bytes"
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
)

// BackupMultilistPath computes a request path to the backup action of multilist.
func BackupMultilistPath() string {

	return fmt.Sprintf("/xlist/backup")
}

// Backup lists.
// If no lists, nor any search is specified all lists are backed up.A callback is provided to check progress.
func (c *Client) BackupMultilist(ctx context.Context, path string, payload *MultiListBackup, contentType string) (*http.Response, error) {
	req, err := c.NewBackupMultilistRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewBackupMultilistRequest create the request corresponding to the backup action endpoint of the multilist resource.
func (c *Client) NewBackupMultilistRequest(ctx context.Context, path string, payload *MultiListBackup, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// CreateMultilistPath computes a request path to the create action of multilist.
func CreateMultilistPath() string {

	return fmt.Sprintf("/xlist/elements")
}

// Create elements in lists
func (c *Client) CreateMultilist(ctx context.Context, path string, payload *ListPayloadQL, errorsOnly *bool, results *bool, contentType string) (*http.Response, error) {
	req, err := c.NewCreateMultilistRequest(ctx, path, payload, errorsOnly, results, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewCreateMultilistRequest create the request corresponding to the create action endpoint of the multilist resource.
func (c *Client) NewCreateMultilistRequest(ctx context.Context, path string, payload *ListPayloadQL, errorsOnly *bool, results *bool, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if errorsOnly != nil {
		tmp66 := strconv.FormatBool(*errorsOnly)
		values.Set("errors_only", tmp66)
	}
	if results != nil {
		tmp67 := strconv.FormatBool(*results)
		values.Set("results", tmp67)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// DeleteMultilistPath computes a request path to the delete action of multilist.
func DeleteMultilistPath(elementID string) string {
	param0 := elementID

	return fmt.Sprintf("/xlist/elements/%s", param0)
}

// Delete element in multiple lists.
// If element is not found the operation is considered a success
func (c *Client) DeleteMultilist(ctx context.Context, path string, allInSets []string, errorsOnly *bool, lists []string, matchMetadata *string) (*http.Response, error) {
	req, err := c.NewDeleteMultilistRequest(ctx, path, allInSets, errorsOnly, lists, matchMetadata)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewDeleteMultilistRequest create the request corresponding to the delete action endpoint of the multilist resource.
func (c *Client) NewDeleteMultilistRequest(ctx context.Context, path string, allInSets []string, errorsOnly *bool, lists []string, matchMetadata *string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	for _, p := range allInSets {
		tmp68 := p
		values.Add("all_in_sets", tmp68)
	}
	if errorsOnly != nil {
		tmp69 := strconv.FormatBool(*errorsOnly)
		values.Set("errors_only", tmp69)
	}
	for _, p := range lists {
		tmp70 := p
		values.Add("lists", tmp70)
	}
	if matchMetadata != nil {
		values.Set("match_metadata", *matchMetadata)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// GetMultilistPath computes a request path to the get action of multilist.
func GetMultilistPath(elementID string) string {
	param0 := elementID

	return fmt.Sprintf("/xlist/elements/%s", param0)
}

// Get Element in multiple lists
func (c *Client) GetMultilist(ctx context.Context, path string, allInSets []string, lists []string, matchMetadata *string) (*http.Response, error) {
	req, err := c.NewGetMultilistRequest(ctx, path, allInSets, lists, matchMetadata)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewGetMultilistRequest create the request corresponding to the get action endpoint of the multilist resource.
func (c *Client) NewGetMultilistRequest(ctx context.Context, path string, allInSets []string, lists []string, matchMetadata *string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	for _, p := range allInSets {
		tmp71 := p
		values.Add("all_in_sets", tmp71)
	}
	for _, p := range lists {
		tmp72 := p
		values.Add("lists", tmp72)
	}
	if matchMetadata != nil {
		values.Set("match_metadata", *matchMetadata)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// PutMultilistPath computes a request path to the put action of multilist.
func PutMultilistPath() string {

	return fmt.Sprintf("/xlist/elements")
}

// Update multiple elements in lists
func (c *Client) PutMultilist(ctx context.Context, path string, payload *ListPayloadQL, errorsOnly *bool, results *bool, contentType string) (*http.Response, error) {
	req, err := c.NewPutMultilistRequest(ctx, path, payload, errorsOnly, results, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewPutMultilistRequest create the request corresponding to the put action endpoint of the multilist resource.
func (c *Client) NewPutMultilistRequest(ctx context.Context, path string, payload *ListPayloadQL, errorsOnly *bool, results *bool, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if errorsOnly != nil {
		tmp73 := strconv.FormatBool(*errorsOnly)
		values.Set("errors_only", tmp73)
	}
	if results != nil {
		tmp74 := strconv.FormatBool(*results)
		values.Set("results", tmp74)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// ReindexMultilistPath computes a request path to the reindex action of multilist.
func ReindexMultilistPath() string {

	return fmt.Sprintf("/xlist/reindex")
}

// Reindex lists.
// If no lists, nor any search is specified all lists are reindexed.
func (c *Client) ReindexMultilist(ctx context.Context, path string, payload *ListQL, errorsOnly *bool, contentType string) (*http.Response, error) {
	req, err := c.NewReindexMultilistRequest(ctx, path, payload, errorsOnly, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewReindexMultilistRequest create the request corresponding to the reindex action endpoint of the multilist resource.
func (c *Client) NewReindexMultilistRequest(ctx context.Context, path string, payload *ListQL, errorsOnly *bool, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if errorsOnly != nil {
		tmp75 := strconv.FormatBool(*errorsOnly)
		values.Set("errors_only", tmp75)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// RestoreMultilistPath computes a request path to the restore action of multilist.
func RestoreMultilistPath() string {

	return fmt.Sprintf("/xlist/restore")
}

// Restore lists. Body must contain binary data with backup data, unless 'src' is specified.
func (c *Client) RestoreMultilist(ctx context.Context, path string, keep *bool, listIDPrefix *string, listIDSuffix *string, src *string, srcFile *string) (*http.Response, error) {
	req, err := c.NewRestoreMultilistRequest(ctx, path, keep, listIDPrefix, listIDSuffix, src, srcFile)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewRestoreMultilistRequest create the request corresponding to the restore action endpoint of the multilist resource.
func (c *Client) NewRestoreMultilistRequest(ctx context.Context, path string, keep *bool, listIDPrefix *string, listIDSuffix *string, src *string, srcFile *string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if keep != nil {
		tmp76 := strconv.FormatBool(*keep)
		values.Set("keep", tmp76)
	}
	if listIDPrefix != nil {
		values.Set("list_id_prefix", *listIDPrefix)
	}
	if listIDSuffix != nil {
		values.Set("list_id_suffix", *listIDSuffix)
	}
	if src != nil {
		values.Set("src", *src)
	}
	if srcFile != nil {
		values.Set("src_file", *srcFile)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}

// VerifyMultilistPath computes a request path to the verify action of multilist.
func VerifyMultilistPath() string {

	return fmt.Sprintf("/xlist/verify")
}

// Verify lists.
// If no lists, nor any search is specified all lists are checked.
func (c *Client) VerifyMultilist(ctx context.Context, path string, payload *ListQL, clear *bool, elements *bool, errorsOnly *bool, repair *bool, contentType string) (*http.Response, error) {
	req, err := c.NewVerifyMultilistRequest(ctx, path, payload, clear, elements, errorsOnly, repair, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewVerifyMultilistRequest create the request corresponding to the verify action endpoint of the multilist resource.
func (c *Client) NewVerifyMultilistRequest(ctx context.Context, path string, payload *ListQL, clear *bool, elements *bool, errorsOnly *bool, repair *bool, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if clear != nil {
		tmp77 := strconv.FormatBool(*clear)
		values.Set("clear", tmp77)
	}
	if elements != nil {
		tmp78 := strconv.FormatBool(*elements)
		values.Set("elements", tmp78)
	}
	if errorsOnly != nil {
		tmp79 := strconv.FormatBool(*errorsOnly)
		values.Set("errors_only", tmp79)
	}
	if repair != nil {
		tmp80 := strconv.FormatBool(*repair)
		values.Set("repair", tmp80)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	if c.JWTSigner != nil {
		if err := c.JWTSigner.Sign(req); err != nil {
			return nil, err
		}
	}
	return req, nil
}
