// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "rankdb": CLI Commands
//
// Command:
// $ goagen
// --design=github.com/Vivino/rankdb/api/design
// --out=$(GOPATH)/src/github.com/Vivino/rankdb/api
// --version=v1.3.1

package cli

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/url"
	"os"
	"path"
	"strconv"
	"strings"
	"time"

	"github.com/Vivino/rankdb/api/client"
	"github.com/goadesign/goa"
	goaclient "github.com/goadesign/goa/client"
	uuid "github.com/goadesign/goa/uuid"
	"github.com/spf13/cobra"
)

type (
	// DeleteBackupCommand is the command line data structure for the delete action of backup
	DeleteBackupCommand struct {
		BackupID    string
		PrettyPrint bool
	}

	// StatusBackupCommand is the command line data structure for the status action of backup
	StatusBackupCommand struct {
		BackupID    string
		PrettyPrint bool
	}

	// CreateElementsCommand is the command line data structure for the create action of elements
	CreateElementsCommand struct {
		Payload     string
		ContentType string
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID string
		// Return this number of elements above and below the current element in `neighbors` field.
		Range       int
		PrettyPrint bool
	}

	// DeleteElementsCommand is the command line data structure for the delete action of elements
	DeleteElementsCommand struct {
		// ID of element
		ElementID string
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID      string
		PrettyPrint bool
	}

	// DeleteMultiElementsCommand is the command line data structure for the delete-multi action of elements
	DeleteMultiElementsCommand struct {
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID string
		// IDs of elements
		ElementIds  []string
		PrettyPrint bool
	}

	// GetElementsCommand is the command line data structure for the get action of elements
	GetElementsCommand struct {
		// ID of element
		ElementID string
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID string
		// Return this number of elements above and below the current element in `neighbors` field.
		Range       int
		PrettyPrint bool
	}

	// GetAroundElementsCommand is the command line data structure for the get-around action of elements
	GetAroundElementsCommand struct {
		Payload     string
		ContentType string
		// ID of element
		ElementID string
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID string
		// Return this number of elements above and below the current element in `neighbors` field.
		Range       int
		PrettyPrint bool
	}

	// GetMultiElementsCommand is the command line data structure for the get-multi action of elements
	GetMultiElementsCommand struct {
		Payload     string
		ContentType string
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID      string
		PrettyPrint bool
	}

	// PutElementsCommand is the command line data structure for the put action of elements
	PutElementsCommand struct {
		Payload     string
		ContentType string
		// ID of element
		ElementID string
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID string
		// Return this number of elements above and below the current element in `neighbors` field.
		Range       int
		PrettyPrint bool
	}

	// PutMultiElementsCommand is the command line data structure for the put-multi action of elements
	PutMultiElementsCommand struct {
		Payload     string
		ContentType string
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID string
		// Return results of the operation. If disabled, operations will be faster and require less memory.
		Results     string
		PrettyPrint bool
	}

	// HealthHealthCommand is the command line data structure for the health action of health
	HealthHealthCommand struct {
		PrettyPrint bool
	}

	// RootHealthCommand is the command line data structure for the root action of health
	RootHealthCommand struct {
		PrettyPrint bool
	}

	// JWTJWTCommand is the command line data structure for the jwt action of jwt
	JWTJWTCommand struct {
		// Expire token in this many minutes. Default is 24 hours.
		Expire int
		// Create key with list restrictions.
		// Use commas to separate multiple elements
		OnlyElements string
		// Create key with list restrictions.
		// Use commas to separate multiple lists
		OnlyLists string
		// Create key with scope
		Scope       string
		PrettyPrint bool
	}

	// CloneListsCommand is the command line data structure for the clone action of lists
	CloneListsCommand struct {
		Payload     string
		ContentType string
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID      string
		PrettyPrint bool
	}

	// CreateListsCommand is the command line data structure for the create action of lists
	CreateListsCommand struct {
		Payload     string
		ContentType string
		// Replace list if exists.
		Replace     string
		PrettyPrint bool
	}

	// DeleteListsCommand is the command line data structure for the delete action of lists
	DeleteListsCommand struct {
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID      string
		PrettyPrint bool
	}

	// GetListsCommand is the command line data structure for the get action of lists
	GetListsCommand struct {
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID string
		// Include top_element and bottom_element in result.
		TopBottom   string
		PrettyPrint bool
	}

	// GetPercentileListsCommand is the command line data structure for the get-percentile action of lists
	GetPercentileListsCommand struct {
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID string
		// Return median percentile element.
		// If the percentile is between two elements, the element with the highest score is returned.
		// Value must be parseable as a float point number and must be between 0.0 and 100.0
		FromTop string
		// Return this number of elements above and below the current element in `neighbors` field.
		Range       int
		PrettyPrint bool
	}

	// GetRangeListsCommand is the command line data structure for the get-range action of lists
	GetRangeListsCommand struct {
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID string
		// First result will be at this rank from the bottom of the list.
		FromBottom int
		// First result will be at this rank from the top of the list.
		FromTop int
		// Number of results to return
		Limit       int
		PrettyPrint bool
	}

	// GetAllListsCommand is the command line data structure for the get_all action of lists
	GetAllListsCommand struct {
		// Start with element following this ID. Empty will return from start.
		AfterID string
		// Return elements preceding this ID.
		BeforeID string
		// Maximum Number of results
		Limit       int
		PrettyPrint bool
	}

	// ReindexListsCommand is the command line data structure for the reindex action of lists
	ReindexListsCommand struct {
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID      string
		PrettyPrint bool
	}

	// RepairListsCommand is the command line data structure for the repair action of lists
	RepairListsCommand struct {
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID string
		// Clear list if unable to repair
		Clear       string
		PrettyPrint bool
	}

	// VerifyListsCommand is the command line data structure for the verify action of lists
	VerifyListsCommand struct {
		// The ID of the list to apply the operation on.
		// Can be `a` to `z` (both upper/lower case), `0` to `9` or one of these characters `_-.`
		ListID string
		// Clear list if unable to repair
		Clear string
		// Attempt to repair list
		Repair      string
		PrettyPrint bool
	}

	// BackupMultilistCommand is the command line data structure for the backup action of multilist
	BackupMultilistCommand struct {
		Payload     string
		ContentType string
		PrettyPrint bool
	}

	// CreateMultilistCommand is the command line data structure for the create action of multilist
	CreateMultilistCommand struct {
		Payload     string
		ContentType string
		// Returns errors only. If disabled, operations will be faster and require less memory.
		ErrorsOnly string
		// Return results of the operation. If disabled, operations will be faster and require less memory.
		Results     string
		PrettyPrint bool
	}

	// DeleteMultilistCommand is the command line data structure for the delete action of multilist
	DeleteMultilistCommand struct {
		// ID of element
		ElementID string
		// Include all lists in these sets
		AllInSets []string
		// Returns errors only. If disabled, operations will be faster and require less memory.
		ErrorsOnly string
		// Include lists that match exact list names
		Lists []string
		// Include lists that match all values in metadata.
		// Payload must be valid json with string->string values.
		// Example: {"country":"dk","game":"match4"}
		MatchMetadata string
		PrettyPrint   bool
	}

	// GetMultilistCommand is the command line data structure for the get action of multilist
	GetMultilistCommand struct {
		// ID of element
		ElementID string
		// Include all lists in these sets
		AllInSets []string
		// Include lists that match exact list names
		Lists []string
		// Include lists that match all values in metadata.
		// Payload must be valid json with string->string values.
		// Example: {"country":"dk","game":"match4"}
		MatchMetadata string
		PrettyPrint   bool
	}

	// PutMultilistCommand is the command line data structure for the put action of multilist
	PutMultilistCommand struct {
		Payload     string
		ContentType string
		// Returns errors only. If disabled, operations will be faster and require less memory.
		ErrorsOnly string
		// Return results of the operation. If disabled, operations will be faster and require less memory.
		Results     string
		PrettyPrint bool
	}

	// ReindexMultilistCommand is the command line data structure for the reindex action of multilist
	ReindexMultilistCommand struct {
		Payload     string
		ContentType string
		// Returns errors only. If disabled, operations will be faster and require less memory.
		ErrorsOnly  string
		PrettyPrint bool
	}

	// RestoreMultilistCommand is the command line data structure for the restore action of multilist
	RestoreMultilistCommand struct {
		// Keep existing lists. Only restore missing lists
		Keep string
		// Optional alternative list id prefix.
		// If not provided the original list id/segment ids will be used and any existing list will be overwritten.
		ListIDPrefix string
		// Optional alternative list id suffix.
		// If not provided the original list id/segment ids will be used and any existing list will be overwritten.
		ListIDSuffix string
		// The body will not contain any data. Instead load data from provided URL.
		// The call will return when the backup has finished.
		// If the source is s3, the source should be defined as s3://bucket/path/file.bin. Replace bucket and path+file
		Src string
		// The body will not contain any data. Instead load data from file from this path.
		// The call will return when the backup has finished.
		SrcFile     string
		PrettyPrint bool
	}

	// VerifyMultilistCommand is the command line data structure for the verify action of multilist
	VerifyMultilistCommand struct {
		Payload     string
		ContentType string
		// Clear list if unable to repair
		Clear string
		// Verify elements as well
		Elements string
		// Returns errors only. If disabled, operations will be faster and require less memory.
		ErrorsOnly string
		// Repair lists with problems automatically.
		Repair      string
		PrettyPrint bool
	}

	// DownloadCommand is the command line data structure for the download command.
	DownloadCommand struct {
		// OutFile is the path to the download output file.
		OutFile string
	}
)

// RegisterCommands registers the resource action CLI commands.
func RegisterCommands(app *cobra.Command, c *client.Client) {
	var command, sub *cobra.Command
	command = &cobra.Command{
		Use: "backup",
		Short: `Backup lists.
If no lists, nor any search is specified all lists are backed up.A callback is provided to check progress.`,
	}
	tmp1 := new(BackupMultilistCommand)
	sub = &cobra.Command{
		Use:   `multilist ["/xlist/backup"]`,
		Short: `Cross-list operations`,
		Long: `Cross-list operations

Payload example:

{
   "destination": {
      "path": "./backup.bin",
      "server_list_id_prefix": "Molestiae aspernatur mollitia commodi id deserunt.",
      "server_list_id_suffix": "Reiciendis voluptate ea id aperiam nulla.",
      "type": "file"
   },
   "lists": {
      "all_in_sets": [
         "storage-set",
         "backup-set"
      ],
      "lists": [
         "highscore-dk-all",
         "highscore-uk-all"
      ],
      "match_metadata": {
         "country": "dk"
      }
   }
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp1.Run(c, args) },
	}
	tmp1.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp1.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "clone",
		Short: `Creates a clone of the list to a new list with the supplied metadata.
The URL list is the source and the payload must contain the new list ID.`,
	}
	tmp2 := new(CloneListsCommand)
	sub = &cobra.Command{
		Use:   `lists ["/lists/LIST_ID/clone"]`,
		Short: ``,
		Long: `

Payload example:

{
   "id": "highscore-list",
   "load_index": false,
   "merge_size": 500,
   "metadata": {
      "country": "dk",
      "game": "2"
   },
   "populate": [
      {
         "id": 100,
         "payload": {
            "country": "dk",
            "name": "Mark Anthony"
         },
         "score": 100,
         "tie_breaker": 2000
      },
      {
         "id": 100,
         "payload": {
            "country": "dk",
            "name": "Mark Anthony"
         },
         "score": 100,
         "tie_breaker": 2000
      }
   ],
   "set": "storage-set",
   "split_size": 2000
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp2.Run(c, args) },
	}
	tmp2.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp2.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "create",
		Short: `create action`,
	}
	tmp3 := new(CreateElementsCommand)
	sub = &cobra.Command{
		Use:   `elements ["/lists/LIST_ID/elements"]`,
		Short: ``,
		Long: `

Payload example:

{
   "id": 100,
   "payload": {
      "country": "dk",
      "name": "Mark Anthony"
   },
   "score": 100,
   "tie_breaker": 2000
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp3.Run(c, args) },
	}
	tmp3.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp3.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp4 := new(CreateListsCommand)
	sub = &cobra.Command{
		Use:   `lists ["/lists"]`,
		Short: ``,
		Long: `

Payload example:

{
   "id": "highscore-list",
   "load_index": false,
   "merge_size": 500,
   "metadata": {
      "country": "dk",
      "game": "2"
   },
   "populate": [
      {
         "id": 100,
         "payload": {
            "country": "dk",
            "name": "Mark Anthony"
         },
         "score": 100,
         "tie_breaker": 2000
      },
      {
         "id": 100,
         "payload": {
            "country": "dk",
            "name": "Mark Anthony"
         },
         "score": 100,
         "tie_breaker": 2000
      }
   ],
   "set": "storage-set",
   "split_size": 2000
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp4.Run(c, args) },
	}
	tmp4.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp4.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp5 := new(CreateMultilistCommand)
	sub = &cobra.Command{
		Use:   `multilist ["/xlist/elements"]`,
		Short: `Cross-list operations`,
		Long: `Cross-list operations

Payload example:

{
   "all_in_sets": [
      "storage-set",
      "backup-set"
   ],
   "lists": [
      "highscore-dk-all",
      "highscore-uk-all"
   ],
   "match_metadata": {
      "country": "dk"
   },
   "payload": [
      {
         "id": 100,
         "payload": {
            "country": "dk",
            "name": "Mark Anthony"
         },
         "score": 100,
         "tie_breaker": 2000
      }
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp5.Run(c, args) },
	}
	tmp5.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp5.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "delete",
		Short: `delete action`,
	}
	tmp6 := new(DeleteBackupCommand)
	sub = &cobra.Command{
		Use:   `backup ["/backup/BACKUP_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp6.Run(c, args) },
	}
	tmp6.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp6.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp7 := new(DeleteElementsCommand)
	sub = &cobra.Command{
		Use:   `elements ["/lists/LIST_ID/elements/ELEMENT_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp7.Run(c, args) },
	}
	tmp7.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp7.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp8 := new(DeleteListsCommand)
	sub = &cobra.Command{
		Use:   `lists ["/lists/LIST_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp8.Run(c, args) },
	}
	tmp8.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp8.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp9 := new(DeleteMultilistCommand)
	sub = &cobra.Command{
		Use:   `multilist ["/xlist/elements/ELEMENT_ID"]`,
		Short: `Cross-list operations`,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp9.Run(c, args) },
	}
	tmp9.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp9.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "delete-multi",
		Short: `Delete Multiple Elements in list.If an element does not exist, success is returned.
`,
	}
	tmp10 := new(DeleteMultiElementsCommand)
	sub = &cobra.Command{
		Use:   `elements ["/lists/LIST_ID/elements"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp10.Run(c, args) },
	}
	tmp10.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp10.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "get",
		Short: `get action`,
	}
	tmp11 := new(GetElementsCommand)
	sub = &cobra.Command{
		Use:   `elements ["/lists/LIST_ID/elements/ELEMENT_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp11.Run(c, args) },
	}
	tmp11.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp11.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp12 := new(GetListsCommand)
	sub = &cobra.Command{
		Use:   `lists ["/lists/LIST_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp12.Run(c, args) },
	}
	tmp12.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp12.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp13 := new(GetMultilistCommand)
	sub = &cobra.Command{
		Use:   `multilist ["/xlist/elements/ELEMENT_ID"]`,
		Short: `Cross-list operations`,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp13.Run(c, args) },
	}
	tmp13.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp13.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "get-all",
		Short: `Get multiple lists.
Lists are sorted lexicographically. See https://golang.org/pkg/strings/#Compare`,
	}
	tmp14 := new(GetAllListsCommand)
	sub = &cobra.Command{
		Use:   `lists ["/lists"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp14.Run(c, args) },
	}
	tmp14.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp14.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "get-around",
		Short: `Get relation of one element to multiple specific elements.
The element will have local_from_top and local_from_bottom populated.Elements that are not found are ignored.
`,
	}
	tmp15 := new(GetAroundElementsCommand)
	sub = &cobra.Command{
		Use:   `elements ["/lists/LIST_ID/elements/ELEMENT_ID/around"]`,
		Short: ``,
		Long: `

Payload example:

{
   "element_ids": [
      120,
      340,
      550
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp15.Run(c, args) },
	}
	tmp15.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp15.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "get-multi",
		Short: `Get Multiple Elements in list.
Will return 404 if list cannot be found, OK even if no elements are found.`,
	}
	tmp16 := new(GetMultiElementsCommand)
	sub = &cobra.Command{
		Use:   `elements ["/lists/LIST_ID/elements/find"]`,
		Short: ``,
		Long: `

Payload example:

{
   "element_ids": [
      120,
      340,
      550
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp16.Run(c, args) },
	}
	tmp16.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp16.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "get-percentile",
		Short: `Get element at percentile.
Either ` + "`" + `from_top` + "`" + ` or ` + "`" + `from_bottom` + "`" + ` must be supplied`,
	}
	tmp17 := new(GetPercentileListsCommand)
	sub = &cobra.Command{
		Use:   `lists ["/lists/LIST_ID/percentile"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp17.Run(c, args) },
	}
	tmp17.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp17.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "get-range",
		Short: `Get rank range of the list.
Either ` + "`" + `from_top` + "`" + ` or ` + "`" + `from_bottom` + "`" + ` must be supplied`,
	}
	tmp18 := new(GetRangeListsCommand)
	sub = &cobra.Command{
		Use:   `lists ["/lists/LIST_ID/range"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp18.Run(c, args) },
	}
	tmp18.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp18.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "health",
		Short: `Return system information`,
	}
	tmp19 := new(HealthHealthCommand)
	sub = &cobra.Command{
		Use:   `health ["/health"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp19.Run(c, args) },
	}
	tmp19.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp19.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "jwt",
		Short: `JWT key generator.
If left disabled in config, Unauthorized is returned`,
	}
	tmp20 := new(JWTJWTCommand)
	sub = &cobra.Command{
		Use:   `jwt ["/jwt"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp20.Run(c, args) },
	}
	tmp20.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp20.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "put",
		Short: `put action`,
	}
	tmp21 := new(PutElementsCommand)
	sub = &cobra.Command{
		Use:   `elements ["/lists/LIST_ID/elements/ELEMENT_ID"]`,
		Short: ``,
		Long: `

Payload example:

{
   "id": 100,
   "payload": {
      "country": "dk",
      "name": "Mark Anthony"
   },
   "score": 100,
   "tie_breaker": 2000
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp21.Run(c, args) },
	}
	tmp21.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp21.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp22 := new(PutMultilistCommand)
	sub = &cobra.Command{
		Use:   `multilist ["/xlist/elements"]`,
		Short: `Cross-list operations`,
		Long: `Cross-list operations

Payload example:

{
   "all_in_sets": [
      "storage-set",
      "backup-set"
   ],
   "lists": [
      "highscore-dk-all",
      "highscore-uk-all"
   ],
   "match_metadata": {
      "country": "dk"
   },
   "payload": [
      {
         "id": 100,
         "payload": {
            "country": "dk",
            "name": "Mark Anthony"
         },
         "score": 100,
         "tie_breaker": 2000
      }
   ]
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp22.Run(c, args) },
	}
	tmp22.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp22.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "put-multi",
		Short: `Update Multiple Elements in list.If element does not exist, it is created in list.
The returned "not_found" field will never be preset.`,
	}
	tmp23 := new(PutMultiElementsCommand)
	sub = &cobra.Command{
		Use:   `elements ["/lists/LIST_ID/elements"]`,
		Short: ``,
		Long: `

Payload example:

[
   {
      "id": 100,
      "payload": {
         "country": "dk",
         "name": "Mark Anthony"
      },
      "score": 100,
      "tie_breaker": 2000
   },
   {
      "id": 100,
      "payload": {
         "country": "dk",
         "name": "Mark Anthony"
      },
      "score": 100,
      "tie_breaker": 2000
   },
   {
      "id": 100,
      "payload": {
         "country": "dk",
         "name": "Mark Anthony"
      },
      "score": 100,
      "tie_breaker": 2000
   }
]`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp23.Run(c, args) },
	}
	tmp23.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp23.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "reindex",
		Short: `reindex action`,
	}
	tmp24 := new(ReindexListsCommand)
	sub = &cobra.Command{
		Use:   `lists ["/lists/LIST_ID/reindex"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp24.Run(c, args) },
	}
	tmp24.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp24.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp25 := new(ReindexMultilistCommand)
	sub = &cobra.Command{
		Use:   `multilist ["/xlist/reindex"]`,
		Short: `Cross-list operations`,
		Long: `Cross-list operations

Payload example:

{
   "all_in_sets": [
      "storage-set",
      "backup-set"
   ],
   "lists": [
      "highscore-dk-all",
      "highscore-uk-all"
   ],
   "match_metadata": {
      "country": "dk"
   }
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp25.Run(c, args) },
	}
	tmp25.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp25.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use: "repair",
		Short: `Repairs the list, by recreating all segments and indexes.
All access to the list is blocked while operation runs.`,
	}
	tmp26 := new(RepairListsCommand)
	sub = &cobra.Command{
		Use:   `lists ["/lists/LIST_ID/repair"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp26.Run(c, args) },
	}
	tmp26.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp26.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "restore",
		Short: `Restore lists. Body must contain binary data with backup data, unless 'src' is specified.`,
	}
	tmp27 := new(RestoreMultilistCommand)
	sub = &cobra.Command{
		Use:   `multilist ["/xlist/restore"]`,
		Short: `Cross-list operations`,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp27.Run(c, args) },
	}
	tmp27.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp27.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "root",
		Short: `Ping server`,
	}
	tmp28 := new(RootHealthCommand)
	sub = &cobra.Command{
		Use:   `health ["/"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp28.Run(c, args) },
	}
	tmp28.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp28.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "status",
		Short: `Return backup progress`,
	}
	tmp29 := new(StatusBackupCommand)
	sub = &cobra.Command{
		Use:   `backup ["/backup/BACKUP_ID"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp29.Run(c, args) },
	}
	tmp29.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp29.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)
	command = &cobra.Command{
		Use:   "verify",
		Short: `verify action`,
	}
	tmp30 := new(VerifyListsCommand)
	sub = &cobra.Command{
		Use:   `lists ["/lists/LIST_ID/verify"]`,
		Short: ``,
		RunE:  func(cmd *cobra.Command, args []string) error { return tmp30.Run(c, args) },
	}
	tmp30.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp30.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	tmp31 := new(VerifyMultilistCommand)
	sub = &cobra.Command{
		Use:   `multilist ["/xlist/verify"]`,
		Short: `Cross-list operations`,
		Long: `Cross-list operations

Payload example:

{
   "all_in_sets": [
      "storage-set",
      "backup-set"
   ],
   "lists": [
      "highscore-dk-all",
      "highscore-uk-all"
   ],
   "match_metadata": {
      "country": "dk"
   }
}`,
		RunE: func(cmd *cobra.Command, args []string) error { return tmp31.Run(c, args) },
	}
	tmp31.RegisterFlags(sub, c)
	sub.PersistentFlags().BoolVar(&tmp31.PrettyPrint, "pp", false, "Pretty print response body")
	command.AddCommand(sub)
	app.AddCommand(command)

	dl := new(DownloadCommand)
	dlc := &cobra.Command{
		Use:   "download [PATH]",
		Short: "Download file with given path",
		RunE: func(cmd *cobra.Command, args []string) error {
			return dl.Run(c, args)
		},
	}
	dlc.Flags().StringVar(&dl.OutFile, "out", "", "Output file")
	app.AddCommand(dlc)
}

func intFlagVal(name string, parsed int) *int {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func float64FlagVal(name string, parsed float64) *float64 {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func boolFlagVal(name string, parsed bool) *bool {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func stringFlagVal(name string, parsed string) *string {
	if hasFlag(name) {
		return &parsed
	}
	return nil
}

func hasFlag(name string) bool {
	for _, arg := range os.Args[1:] {
		if strings.HasPrefix(arg, "--"+name) {
			return true
		}
	}
	return false
}

func jsonVal(val string) (*interface{}, error) {
	var t interface{}
	err := json.Unmarshal([]byte(val), &t)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func jsonArray(ins []string) ([]interface{}, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []interface{}
	for _, id := range ins {
		val, err := jsonVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, val)
	}
	return vals, nil
}

func timeVal(val string) (*time.Time, error) {
	t, err := time.Parse(time.RFC3339, val)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func timeArray(ins []string) ([]time.Time, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []time.Time
	for _, id := range ins {
		val, err := timeVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

func uuidVal(val string) (*uuid.UUID, error) {
	t, err := uuid.FromString(val)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func uuidArray(ins []string) ([]uuid.UUID, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []uuid.UUID
	for _, id := range ins {
		val, err := uuidVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

func float64Val(val string) (*float64, error) {
	t, err := strconv.ParseFloat(val, 64)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func float64Array(ins []string) ([]float64, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []float64
	for _, id := range ins {
		val, err := float64Val(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

func boolVal(val string) (*bool, error) {
	t, err := strconv.ParseBool(val)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func boolArray(ins []string) ([]bool, error) {
	if ins == nil {
		return nil, nil
	}
	var vals []bool
	for _, id := range ins {
		val, err := boolVal(id)
		if err != nil {
			return nil, err
		}
		vals = append(vals, *val)
	}
	return vals, nil
}

// Run downloads files with given paths.
func (cmd *DownloadCommand) Run(c *client.Client, args []string) error {
	var (
		fnf func(context.Context, string) (int64, error)
		fnd func(context.Context, string, string) (int64, error)

		rpath   = args[0]
		outfile = cmd.OutFile
		logger  = goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
		ctx     = goa.WithLogger(context.Background(), logger)
		err     error
	)

	if rpath[0] != '/' {
		rpath = "/" + rpath
	}
	if strings.HasPrefix(rpath, "/doc/") {
		fnd = c.DownloadDoc
		rpath = rpath[5:]
		if outfile == "" {
			_, outfile = path.Split(rpath)
		}
		goto found
	}
	if strings.HasPrefix(rpath, "/api/swagger/") {
		fnd = c.DownloadSwagger
		rpath = rpath[13:]
		if outfile == "" {
			_, outfile = path.Split(rpath)
		}
		goto found
	}
	return fmt.Errorf("don't know how to download %s", rpath)
found:
	ctx = goa.WithLogContext(ctx, "file", outfile)
	if fnf != nil {
		_, err = fnf(ctx, outfile)
	} else {
		_, err = fnd(ctx, rpath, outfile)
	}
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	return nil
}

// Run makes the HTTP request corresponding to the DeleteBackupCommand command.
func (cmd *DeleteBackupCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/backup/%v", url.QueryEscape(cmd.BackupID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteBackup(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteBackupCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var backupID string
	cc.Flags().StringVar(&cmd.BackupID, "backup_id", backupID, ``)
}

// Run makes the HTTP request corresponding to the StatusBackupCommand command.
func (cmd *StatusBackupCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/backup/%v", url.QueryEscape(cmd.BackupID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.StatusBackup(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *StatusBackupCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var backupID string
	cc.Flags().StringVar(&cmd.BackupID, "backup_id", backupID, ``)
}

// Run makes the HTTP request corresponding to the CreateElementsCommand command.
func (cmd *CreateElementsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/elements", url.QueryEscape(cmd.ListID))
	}
	var payload client.Element
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CreateElements(ctx, path, &payload, intFlagVal("range", cmd.Range), cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateElementsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
	cc.Flags().IntVar(&cmd.Range, "range", 5, `Return this number of elements above and below the current element in `+"`"+`neighbors`+"`"+` field.`)
}

// Run makes the HTTP request corresponding to the DeleteElementsCommand command.
func (cmd *DeleteElementsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/elements/%v", url.QueryEscape(cmd.ListID), url.QueryEscape(cmd.ElementID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteElements(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteElementsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var elementID string
	cc.Flags().StringVar(&cmd.ElementID, "element_id", elementID, `ID of element`)
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
}

// Run makes the HTTP request corresponding to the DeleteMultiElementsCommand command.
func (cmd *DeleteMultiElementsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/elements", url.QueryEscape(cmd.ListID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteMultiElements(ctx, path, cmd.ElementIds)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteMultiElementsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
	var elementIds []string
	cc.Flags().StringSliceVar(&cmd.ElementIds, "element_ids", elementIds, `IDs of elements`)
}

// Run makes the HTTP request corresponding to the GetElementsCommand command.
func (cmd *GetElementsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/elements/%v", url.QueryEscape(cmd.ListID), url.QueryEscape(cmd.ElementID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.GetElements(ctx, path, intFlagVal("range", cmd.Range))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *GetElementsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var elementID string
	cc.Flags().StringVar(&cmd.ElementID, "element_id", elementID, `ID of element`)
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
	cc.Flags().IntVar(&cmd.Range, "range", 5, `Return this number of elements above and below the current element in `+"`"+`neighbors`+"`"+` field.`)
}

// Run makes the HTTP request corresponding to the GetAroundElementsCommand command.
func (cmd *GetAroundElementsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/elements/%v/around", url.QueryEscape(cmd.ListID), url.QueryEscape(cmd.ElementID))
	}
	var payload client.MultiElement
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.GetAroundElements(ctx, path, &payload, intFlagVal("range", cmd.Range), cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *GetAroundElementsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var elementID string
	cc.Flags().StringVar(&cmd.ElementID, "element_id", elementID, `ID of element`)
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
	cc.Flags().IntVar(&cmd.Range, "range", 5, `Return this number of elements above and below the current element in `+"`"+`neighbors`+"`"+` field.`)
}

// Run makes the HTTP request corresponding to the GetMultiElementsCommand command.
func (cmd *GetMultiElementsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/elements/find", url.QueryEscape(cmd.ListID))
	}
	var payload client.MultiElement
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.GetMultiElements(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *GetMultiElementsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
}

// Run makes the HTTP request corresponding to the PutElementsCommand command.
func (cmd *PutElementsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/elements/%v", url.QueryEscape(cmd.ListID), url.QueryEscape(cmd.ElementID))
	}
	var payload client.Element
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.PutElements(ctx, path, &payload, intFlagVal("range", cmd.Range), cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *PutElementsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var elementID string
	cc.Flags().StringVar(&cmd.ElementID, "element_id", elementID, `ID of element`)
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
	cc.Flags().IntVar(&cmd.Range, "range", 5, `Return this number of elements above and below the current element in `+"`"+`neighbors`+"`"+` field.`)
}

// Run makes the HTTP request corresponding to the PutMultiElementsCommand command.
func (cmd *PutMultiElementsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/elements", url.QueryEscape(cmd.ListID))
	}
	var payload client.PutMultiElementsPayload
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp32 *bool
	if cmd.Results != "" {
		var err error
		tmp32, err = boolVal(cmd.Results)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--results", "err", err)
			return err
		}
	}
	resp, err := c.PutMultiElements(ctx, path, payload, tmp32, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *PutMultiElementsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
	var results string
	cc.Flags().StringVar(&cmd.Results, "results", results, `Return results of the operation. If disabled, operations will be faster and require less memory.`)
}

// Run makes the HTTP request corresponding to the HealthHealthCommand command.
func (cmd *HealthHealthCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/health"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.HealthHealth(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *HealthHealthCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
}

// Run makes the HTTP request corresponding to the RootHealthCommand command.
func (cmd *RootHealthCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.RootHealth(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *RootHealthCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
}

// Run makes the HTTP request corresponding to the JWTJWTCommand command.
func (cmd *JWTJWTCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/jwt"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.JWTJWT(ctx, path, cmd.Scope, intFlagVal("expire", cmd.Expire), stringFlagVal("only_elements", cmd.OnlyElements), stringFlagVal("only_lists", cmd.OnlyLists))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *JWTJWTCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().IntVar(&cmd.Expire, "expire", 1440, `Expire token in this many minutes. Default is 24 hours.`)
	var onlyElements string
	cc.Flags().StringVar(&cmd.OnlyElements, "only_elements", onlyElements, `Create key with list restrictions.
Use commas to separate multiple elements`)
	var onlyLists string
	cc.Flags().StringVar(&cmd.OnlyLists, "only_lists", onlyLists, `Create key with list restrictions.
Use commas to separate multiple lists`)
	cc.Flags().StringVar(&cmd.Scope, "scope", "api:read", `Create key with scope`)
}

// Run makes the HTTP request corresponding to the CloneListsCommand command.
func (cmd *CloneListsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/clone", url.QueryEscape(cmd.ListID))
	}
	var payload client.RankList
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.CloneLists(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CloneListsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
}

// Run makes the HTTP request corresponding to the CreateListsCommand command.
func (cmd *CreateListsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/lists"
	}
	var payload client.RankList
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp33 *bool
	if cmd.Replace != "" {
		var err error
		tmp33, err = boolVal(cmd.Replace)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--replace", "err", err)
			return err
		}
	}
	resp, err := c.CreateLists(ctx, path, &payload, tmp33, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateListsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var replace string
	cc.Flags().StringVar(&cmd.Replace, "replace", replace, `Replace list if exists.`)
}

// Run makes the HTTP request corresponding to the DeleteListsCommand command.
func (cmd *DeleteListsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v", url.QueryEscape(cmd.ListID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.DeleteLists(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteListsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
}

// Run makes the HTTP request corresponding to the GetListsCommand command.
func (cmd *GetListsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v", url.QueryEscape(cmd.ListID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp34 *bool
	if cmd.TopBottom != "" {
		var err error
		tmp34, err = boolVal(cmd.TopBottom)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--top_bottom", "err", err)
			return err
		}
	}
	resp, err := c.GetLists(ctx, path, tmp34)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *GetListsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
	var topBottom string
	cc.Flags().StringVar(&cmd.TopBottom, "top_bottom", topBottom, `Include top_element and bottom_element in result.`)
}

// Run makes the HTTP request corresponding to the GetPercentileListsCommand command.
func (cmd *GetPercentileListsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/percentile", url.QueryEscape(cmd.ListID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.GetPercentileLists(ctx, path, stringFlagVal("from_top", cmd.FromTop), intFlagVal("range", cmd.Range))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *GetPercentileListsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
	cc.Flags().StringVar(&cmd.FromTop, "from_top", "50.0", `Return median percentile element.
If the percentile is between two elements, the element with the highest score is returned.
Value must be parseable as a float point number and must be between 0.0 and 100.0`)
	cc.Flags().IntVar(&cmd.Range, "range", 5, `Return this number of elements above and below the current element in `+"`"+`neighbors`+"`"+` field.`)
}

// Run makes the HTTP request corresponding to the GetRangeListsCommand command.
func (cmd *GetRangeListsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/range", url.QueryEscape(cmd.ListID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.GetRangeLists(ctx, path, intFlagVal("from_bottom", cmd.FromBottom), intFlagVal("from_top", cmd.FromTop), intFlagVal("limit", cmd.Limit))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *GetRangeListsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
	var fromBottom int
	cc.Flags().IntVar(&cmd.FromBottom, "from_bottom", fromBottom, `First result will be at this rank from the bottom of the list.`)
	var fromTop int
	cc.Flags().IntVar(&cmd.FromTop, "from_top", fromTop, `First result will be at this rank from the top of the list.`)
	cc.Flags().IntVar(&cmd.Limit, "limit", 25, `Number of results to return`)
}

// Run makes the HTTP request corresponding to the GetAllListsCommand command.
func (cmd *GetAllListsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/lists"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.GetAllLists(ctx, path, stringFlagVal("after_id", cmd.AfterID), stringFlagVal("before_id", cmd.BeforeID), intFlagVal("limit", cmd.Limit))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *GetAllListsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var afterID string
	cc.Flags().StringVar(&cmd.AfterID, "after_id", afterID, `Start with element following this ID. Empty will return from start.`)
	var beforeID string
	cc.Flags().StringVar(&cmd.BeforeID, "before_id", beforeID, `Return elements preceding this ID.`)
	cc.Flags().IntVar(&cmd.Limit, "limit", 25, `Maximum Number of results`)
}

// Run makes the HTTP request corresponding to the ReindexListsCommand command.
func (cmd *ReindexListsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/reindex", url.QueryEscape(cmd.ListID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.ReindexLists(ctx, path)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ReindexListsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
}

// Run makes the HTTP request corresponding to the RepairListsCommand command.
func (cmd *RepairListsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/repair", url.QueryEscape(cmd.ListID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp35 *bool
	if cmd.Clear != "" {
		var err error
		tmp35, err = boolVal(cmd.Clear)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--clear", "err", err)
			return err
		}
	}
	resp, err := c.RepairLists(ctx, path, tmp35)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *RepairListsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
	var clear string
	cc.Flags().StringVar(&cmd.Clear, "clear", clear, `Clear list if unable to repair`)
}

// Run makes the HTTP request corresponding to the VerifyListsCommand command.
func (cmd *VerifyListsCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/lists/%v/verify", url.QueryEscape(cmd.ListID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp36 *bool
	if cmd.Clear != "" {
		var err error
		tmp36, err = boolVal(cmd.Clear)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--clear", "err", err)
			return err
		}
	}
	var tmp37 *bool
	if cmd.Repair != "" {
		var err error
		tmp37, err = boolVal(cmd.Repair)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--repair", "err", err)
			return err
		}
	}
	resp, err := c.VerifyLists(ctx, path, tmp36, tmp37)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *VerifyListsCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var listID string
	cc.Flags().StringVar(&cmd.ListID, "list_id", listID, `The ID of the list to apply the operation on.
Can be `+"`"+`a`+"`"+` to `+"`"+`z`+"`"+` (both upper/lower case), `+"`"+`0`+"`"+` to `+"`"+`9`+"`"+` or one of these characters `+"`"+`_-.`+"`"+``)
	var clear string
	cc.Flags().StringVar(&cmd.Clear, "clear", clear, `Clear list if unable to repair`)
	var repair string
	cc.Flags().StringVar(&cmd.Repair, "repair", repair, `Attempt to repair list`)
}

// Run makes the HTTP request corresponding to the BackupMultilistCommand command.
func (cmd *BackupMultilistCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/xlist/backup"
	}
	var payload client.MultiListBackup
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.BackupMultilist(ctx, path, &payload, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *BackupMultilistCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
}

// Run makes the HTTP request corresponding to the CreateMultilistCommand command.
func (cmd *CreateMultilistCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/xlist/elements"
	}
	var payload client.ListPayloadQL
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp38 *bool
	if cmd.ErrorsOnly != "" {
		var err error
		tmp38, err = boolVal(cmd.ErrorsOnly)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--errors_only", "err", err)
			return err
		}
	}
	var tmp39 *bool
	if cmd.Results != "" {
		var err error
		tmp39, err = boolVal(cmd.Results)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--results", "err", err)
			return err
		}
	}
	resp, err := c.CreateMultilist(ctx, path, &payload, tmp38, tmp39, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *CreateMultilistCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var errorsOnly string
	cc.Flags().StringVar(&cmd.ErrorsOnly, "errors_only", errorsOnly, `Returns errors only. If disabled, operations will be faster and require less memory.`)
	var results string
	cc.Flags().StringVar(&cmd.Results, "results", results, `Return results of the operation. If disabled, operations will be faster and require less memory.`)
}

// Run makes the HTTP request corresponding to the DeleteMultilistCommand command.
func (cmd *DeleteMultilistCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/xlist/elements/%v", url.QueryEscape(cmd.ElementID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp40 *bool
	if cmd.ErrorsOnly != "" {
		var err error
		tmp40, err = boolVal(cmd.ErrorsOnly)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--errors_only", "err", err)
			return err
		}
	}
	resp, err := c.DeleteMultilist(ctx, path, cmd.AllInSets, tmp40, cmd.Lists, stringFlagVal("match_metadata", cmd.MatchMetadata))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *DeleteMultilistCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var elementID string
	cc.Flags().StringVar(&cmd.ElementID, "element_id", elementID, `ID of element`)
	var allInSets []string
	cc.Flags().StringSliceVar(&cmd.AllInSets, "all_in_sets", allInSets, `Include all lists in these sets`)
	var errorsOnly string
	cc.Flags().StringVar(&cmd.ErrorsOnly, "errors_only", errorsOnly, `Returns errors only. If disabled, operations will be faster and require less memory.`)
	var lists []string
	cc.Flags().StringSliceVar(&cmd.Lists, "lists", lists, `Include lists that match exact list names`)
	var matchMetadata string
	cc.Flags().StringVar(&cmd.MatchMetadata, "match_metadata", matchMetadata, `Include lists that match all values in metadata.
Payload must be valid json with string->string values.
Example: {"country":"dk","game":"match4"}`)
}

// Run makes the HTTP request corresponding to the GetMultilistCommand command.
func (cmd *GetMultilistCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = fmt.Sprintf("/xlist/elements/%v", url.QueryEscape(cmd.ElementID))
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	resp, err := c.GetMultilist(ctx, path, cmd.AllInSets, cmd.Lists, stringFlagVal("match_metadata", cmd.MatchMetadata))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *GetMultilistCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var elementID string
	cc.Flags().StringVar(&cmd.ElementID, "element_id", elementID, `ID of element`)
	var allInSets []string
	cc.Flags().StringSliceVar(&cmd.AllInSets, "all_in_sets", allInSets, `Include all lists in these sets`)
	var lists []string
	cc.Flags().StringSliceVar(&cmd.Lists, "lists", lists, `Include lists that match exact list names`)
	var matchMetadata string
	cc.Flags().StringVar(&cmd.MatchMetadata, "match_metadata", matchMetadata, `Include lists that match all values in metadata.
Payload must be valid json with string->string values.
Example: {"country":"dk","game":"match4"}`)
}

// Run makes the HTTP request corresponding to the PutMultilistCommand command.
func (cmd *PutMultilistCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/xlist/elements"
	}
	var payload client.ListPayloadQL
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp41 *bool
	if cmd.ErrorsOnly != "" {
		var err error
		tmp41, err = boolVal(cmd.ErrorsOnly)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--errors_only", "err", err)
			return err
		}
	}
	var tmp42 *bool
	if cmd.Results != "" {
		var err error
		tmp42, err = boolVal(cmd.Results)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--results", "err", err)
			return err
		}
	}
	resp, err := c.PutMultilist(ctx, path, &payload, tmp41, tmp42, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *PutMultilistCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var errorsOnly string
	cc.Flags().StringVar(&cmd.ErrorsOnly, "errors_only", errorsOnly, `Returns errors only. If disabled, operations will be faster and require less memory.`)
	var results string
	cc.Flags().StringVar(&cmd.Results, "results", results, `Return results of the operation. If disabled, operations will be faster and require less memory.`)
}

// Run makes the HTTP request corresponding to the ReindexMultilistCommand command.
func (cmd *ReindexMultilistCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/xlist/reindex"
	}
	var payload client.ListQL
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp43 *bool
	if cmd.ErrorsOnly != "" {
		var err error
		tmp43, err = boolVal(cmd.ErrorsOnly)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--errors_only", "err", err)
			return err
		}
	}
	resp, err := c.ReindexMultilist(ctx, path, &payload, tmp43, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *ReindexMultilistCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var errorsOnly string
	cc.Flags().StringVar(&cmd.ErrorsOnly, "errors_only", errorsOnly, `Returns errors only. If disabled, operations will be faster and require less memory.`)
}

// Run makes the HTTP request corresponding to the RestoreMultilistCommand command.
func (cmd *RestoreMultilistCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/xlist/restore"
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp44 *bool
	if cmd.Keep != "" {
		var err error
		tmp44, err = boolVal(cmd.Keep)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--keep", "err", err)
			return err
		}
	}
	resp, err := c.RestoreMultilist(ctx, path, tmp44, stringFlagVal("list_id_prefix", cmd.ListIDPrefix), stringFlagVal("list_id_suffix", cmd.ListIDSuffix), stringFlagVal("src", cmd.Src), stringFlagVal("src_file", cmd.SrcFile))
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *RestoreMultilistCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	var keep string
	cc.Flags().StringVar(&cmd.Keep, "keep", keep, `Keep existing lists. Only restore missing lists`)
	var listIDPrefix string
	cc.Flags().StringVar(&cmd.ListIDPrefix, "list_id_prefix", listIDPrefix, `Optional alternative list id prefix.
If not provided the original list id/segment ids will be used and any existing list will be overwritten.`)
	var listIDSuffix string
	cc.Flags().StringVar(&cmd.ListIDSuffix, "list_id_suffix", listIDSuffix, `Optional alternative list id suffix.
If not provided the original list id/segment ids will be used and any existing list will be overwritten.`)
	var src string
	cc.Flags().StringVar(&cmd.Src, "src", src, `The body will not contain any data. Instead load data from provided URL.
The call will return when the backup has finished.
If the source is s3, the source should be defined as s3://bucket/path/file.bin. Replace bucket and path+file`)
	var srcFile string
	cc.Flags().StringVar(&cmd.SrcFile, "src_file", srcFile, `The body will not contain any data. Instead load data from file from this path.
The call will return when the backup has finished.`)
}

// Run makes the HTTP request corresponding to the VerifyMultilistCommand command.
func (cmd *VerifyMultilistCommand) Run(c *client.Client, args []string) error {
	var path string
	if len(args) > 0 {
		path = args[0]
	} else {
		path = "/xlist/verify"
	}
	var payload client.ListQL
	if cmd.Payload != "" {
		err := json.Unmarshal([]byte(cmd.Payload), &payload)
		if err != nil {
			return fmt.Errorf("failed to deserialize payload: %s", err)
		}
	}
	logger := goa.NewLogger(log.New(os.Stderr, "", log.LstdFlags))
	ctx := goa.WithLogger(context.Background(), logger)
	var tmp45 *bool
	if cmd.Clear != "" {
		var err error
		tmp45, err = boolVal(cmd.Clear)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--clear", "err", err)
			return err
		}
	}
	var tmp46 *bool
	if cmd.Elements != "" {
		var err error
		tmp46, err = boolVal(cmd.Elements)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--elements", "err", err)
			return err
		}
	}
	var tmp47 *bool
	if cmd.ErrorsOnly != "" {
		var err error
		tmp47, err = boolVal(cmd.ErrorsOnly)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--errors_only", "err", err)
			return err
		}
	}
	var tmp48 *bool
	if cmd.Repair != "" {
		var err error
		tmp48, err = boolVal(cmd.Repair)
		if err != nil {
			goa.LogError(ctx, "failed to parse flag into *bool value", "flag", "--repair", "err", err)
			return err
		}
	}
	resp, err := c.VerifyMultilist(ctx, path, &payload, tmp45, tmp46, tmp47, tmp48, cmd.ContentType)
	if err != nil {
		goa.LogError(ctx, "failed", "err", err)
		return err
	}

	goaclient.HandleResponse(c.Client, resp, cmd.PrettyPrint)
	return nil
}

// RegisterFlags registers the command flags with the command line.
func (cmd *VerifyMultilistCommand) RegisterFlags(cc *cobra.Command, c *client.Client) {
	cc.Flags().StringVar(&cmd.Payload, "payload", "", "Request body encoded in JSON")
	cc.Flags().StringVar(&cmd.ContentType, "content", "", "Request content type override, e.g. 'application/x-www-form-urlencoded'")
	var clear string
	cc.Flags().StringVar(&cmd.Clear, "clear", clear, `Clear list if unable to repair`)
	var elements string
	cc.Flags().StringVar(&cmd.Elements, "elements", elements, `Verify elements as well`)
	var errorsOnly string
	cc.Flags().StringVar(&cmd.ErrorsOnly, "errors_only", errorsOnly, `Returns errors only. If disabled, operations will be faster and require less memory.`)
	var repair string
	cc.Flags().StringVar(&cmd.Repair, "repair", repair, `Repair lists with problems automatically.`)
}
